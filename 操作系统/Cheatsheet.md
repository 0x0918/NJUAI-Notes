# Cheatsheet

## 一、进程和线程

1. 进程和线程的各种状态转换
    1. 新生状态（new）：表示一个进程刚刚被创建出来，还未完成初始化，不能被调度运行。经过初始化后，进程进入预备状态。
    2. 预备状态（ready）：该状态表示进程可以被调度执行，但还未被调度器选择。在被调度器选择执行后，进程进入运行状态。
    3. 运行状态（running）：该状态表示进程正在 CPU 上运行。当一个进程执行一段时间后，调度器可以选择中断它并放回调度队列，进而进入预备状态。如果进程需要等待一些外部事件，例如某个 I/O 请求的完成，就可以放弃 CPU 进入阻塞状态。当进程运行结束，它就会进入终止状态。
    4. 阻塞状态（blocked）：该状态表示该进程需要等待外部时间，例如某个 I/O 的完成，暂时无法被调度。当该进程等待的外部事件完成后，就会进入预备状态。
    5. 终止状态（terminated）：该状态表示进程已经完成了执行，且不会再被调度。
2. 系统调用
    1. 系统调用是一种特殊的异常，是操作系统为用户程序提供服务的一种手段。内核实现系统调用是以一个软中断的形式，即陷阱指令，如 i386 的 `int 0x80` 指令实现的。
3. 进程控制块 (PCB)
    1. 在内核中，每个进程都通过一个数据结构来保存它相关的状态，如它的进程标识符 PID、进程状态、虚拟内存状态、打开的文件等，这个数据结构称为进程控制块 PCB。
4. 多道程序设计
    1. 上下文切换
    2. CPU 利用率: 用于真实计算的 CPU 时间比例
        1. 假设等待 I/O 时间与停留内存时间之比为 $p$, 则 $n$ 个独立进程的 CPU 利用率为 $1-p^{n}$.
5. 线程控制块 (TCB)


## 二、调度

1. 调度的指标
    1. 吞吐: 系统每小时完成的作业数量.
    2. 周转时间: 从一个批处理作业提交时刻开始, 直到该作业完成时刻为止的统计平均时间.
    3. CPU 利用率: CPU 利用率常常用于对批处理系统的度量.
    4. 响应时间: 对于交互式系统来说很重要, 即从发出命令到得到响应之间的时间.
    5. 均衡性: 用户对一件事情需要的时间的固有看法.
    6. 截止时间: 实时系统必须要满足截止时间.
    7. 可预测性: 涉及多媒体的实时系统, 人的耳朵和眼睛十分灵敏, 所以进程调度必须是高度可预测和有规律的.
2. 批处理系统的调度
    1. 先来先服务 (FCFS, FIFO): 当新作业进入, 排到队尾; 当进程被堵塞, 就接着运行队头任务; 当阻塞进程变为就绪时, 进入队尾.
    2. 最短作业优先 (SJF)
    3. 最短剩余时间优先 (SRTN)
3. 交互式系统中的调度
    1. 轮转调度 (RR)
    2. 优先级调度 (PS)
    3. 多级反馈队列 (MLFQ)
        1. 短任务拥有更高的优先级. MLFQ 会为每个任务设置任务的最大运行时间, 如果超过了最大时间, 就会将该任务的优先级减一.
        2. 低优先级的任务采用更长的时间片.
        3. 定时地将所有任务地优先级提升到最高, 保证不会有饥饿.
4. 实时系统的调度
    1. 准入控制: 假设有 $m$ 个任务, 其中第 $i$ 个任务的运行时间记为 $C_i$, 周期记为 $T_i$, 任务在单位时间内对 CPU 的利用率则为 $C_i / T_i$, 则总 CPU 利用率 $U = \sum_{i=1}^{m} C_i / T_i \le 1$.
    2. 单调速率调度 (RM)
        1. 速率指的是任务的到达速率, 它是任务周期的倒数, 即 $1 / T$.
        2. 需要预测任务的周期 $T$, 并且通过周期静态地为每个任务分配一个优先级, 任务的周期越短, 则优先级越高, RM 策略还支持抢占调度, 高优先级任务可以强制低优先级任务执行.
        3. 在所有静态优先级的实时调度策略中, RM 策略是最优的.
        4. RM 策略需要调度 $N$ 个任务时, 最坏情况下的 CPU 利用率为 $N * (2^{1 / N} - 1)$. 两个任务约为 $83\%$, 无限多个任务时约为 $69\%$.
    3. 最早截止期限优先 (EDF)


## 三、内存管理

1. 内存管理: 管理所有和内存相关的操作和保存在主存中的资源, 使得多个进程能够使用主存和资源.
    1. 记录所有被用到的内存;
    2. 动态分配内存;
    3. 权限管理和内存保护;
    4. 回收不需要的内存;
    5. 最大化内存使用率和系统处理能力.
2. 地址空间: 就像进程概念创造了一类抽象的 CPU 以运行程序一样, 地址空间为程序创造了一种抽象的内存. 地址空间时一个进程可用于寻址内存的一套地址集合.每个进程都有一个自己的地址空间, 并且这个地址空间独立于其他进程的地址空间.
3. 动态重定位: 使用基址寄存器和界限寄存器将每个进程的地址空间映射到物理内存的不同部分.
4. 连续内存分配:
    1. 首次适配 (first fit): 沿着链表搜索, 直到找到一个空闲区.
    2. 最佳适配 (best fit): 搜索整个链表, 找出能够容纳进程的最小空闲区.
    3. 最差适配 (worst fit): 总是分配最大的可用空闲区.
    4. 快速适配 (quick fit): 为常用的空闲区维护单独的链表, 类似按照大小对空闲区链表排序, 以便提高最佳适配算法的速度.
5. 内部碎片和外部碎片
    1. 内部碎片: 分页时一个页面过大, 正文段、数据段和堆栈区很可能不会恰好装满整数个页面, 平均的情况下, 最后一个页面有一半是空的, 多余的空间就被浪费掉了, 这种浪费称为内部碎片.
    2. 外部碎片: 与页相比, 段是不定长的, 多次替代和调换后, 就会形成空闲区, 这种现象称为外部碎片. 这种现象可以通过内存紧缩来解决.