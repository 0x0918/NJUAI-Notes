<style>
h1 {
    text-align: center;
}
h2, h3 {
    page-break-after: avoid; 
}
.center {
    margin: 0 auto;
    width: fit-content;
    margin-top: 2em;
    padding-top: 0.5em;
    padding-bottom: 0.5em;
    margin-bottom: 2em;
}
.title {
    font-weight: bold;
    border-top-style: solid;
    border-bottom-style: solid;
}
.newpage {
    page-break-after: always
}
@media print {
    @page {
        margin: 3cm;
    }
}
</style>

<h1 style="margin-top: 4em">
数字图像处理实验报告
</h1>

# <h1 class="center title">实验二：频域图像处理</h1>

<div class="center">
<h3>院系：人工智能学院</h3>
<h3>姓名：方盛俊</h3>
<h3>学号：201300035</h3>
<h3>邮箱：201300035@smail.nju.edu.cn</h3>
<h3>时间：2022年11月9日</h3>
</div>

<div class="newpage"></div>

<!-- 生成目录 -->

## <h1>目录</h1>

[TOC]

<div class="newpage"></div>

<!-- 文章主体内容 -->

## 一、理论基础

为了自己实现 `fft`, `fft2`, `ifft2` 和 `fspecial` 函数, 我们先研究离散傅里叶变换和快速傅里叶变换的理论基础.

### 1.1 离散傅里叶变换 (DFT)

对于采样后函数 $\displaystyle \tilde{f}(t) = f(t)s_{\Delta T}(t) = \sum_{n=-\infty}^{\infty}f(t)\delta(t-n\Delta T)$

我们可以直接进行傅里叶变换

$
\begin{aligned}
\tilde{F}(\mu) &= \int_{-\infty}^{+\infty}\tilde{f}(t)e^{-j 2\pi \mu t}\mathrm{d}t \\
&= \int_{-\infty}^{+\infty}\sum_{n=-\infty}^{\infty}f(t)\delta(t-n\Delta T)e^{-j 2\pi \mu t}\mathrm{d}t \\
&= \sum_{n=-\infty}^{\infty}\int_{-\infty}^{+\infty}f(t)\delta(t-n\Delta T)e^{-j 2\pi \mu t}\mathrm{d}t \\
&= \sum_{n=-\infty}^{\infty}f_n e^{-j 2\pi \mu n \Delta T}, \quad [f_n=f(n \Delta T)] \\
\end{aligned}
$

我们在已经证明了 $\tilde{F}(\mu)$ 是以 $\displaystyle \frac{1}{\Delta T}$ 为周期的周期函数, 因此我们这里只考虑 $\tilde{F}(\mu)$ 的一个周期 $\displaystyle [0, \frac{1}{\Delta T}]$.

我们在 $\tilde{F}(\mu)$ 的一个周期 $\displaystyle [0, \frac{1}{\Delta T}]$ 上采样 $M$ 个样本, 即通过

$\displaystyle \mu = \frac{m}{M \Delta T}, m = 0,1,2,\cdots, M-1$

采样得到

$\displaystyle F_m = \sum_{n=0}^{M-1}f_n e^{-j 2\pi mn / M}, m = 0,1,2,\cdots, M-1$

此即离散傅里叶变换 (DFT).

同理我们有离散傅里叶反变换 (IDFT)

$\displaystyle f_n = \frac{1}{M}\sum_{m=0}^{M-1}F_m e^{j 2\pi mn / M}, m = 0,1,2,\cdots, M-1$

因此有

- 离散傅里叶变换 (DFT):
    - $\displaystyle F(u) = \sum_{x=0}^{M-1}f(x) e^{-j 2\pi ux / M}, u = 0,1,2,\cdots, M-1$
- 离散傅里叶反变换 (IDFT):
    - $\displaystyle f(x) = \frac{1}{M}\sum_{u=0}^{M-1}F(u) e^{j 2\pi ux / M}, x = 0,1,2,\cdots, M-1$

可以看出表达式不依赖采样间隔和频率间隔, 因此适用于任何均匀取样的有限离散样本集.

并且它们有着无限周期, 周期为 $M$ 的性质.

- $F(u) = F(u+KM)$
- $f(u) = f(x+KM)$

如果我们有

- 采样间隔为 $\Delta T$

则有

- 总时间长度为 $T = M \Delta T$
- 频率间隔为 $\displaystyle \Delta u = \frac{1}{M\Delta T} = \frac{1}{T}$
- 频域范围为 $\displaystyle \Omega = M \Delta u = \frac{1}{\Delta T}$

### 1.2 二维离散傅里叶变换 (DFT2)

- 二维离散傅里叶变换 (DFT)
    - $\displaystyle F(u,v) = \sum_{x=0}^{M-1}\sum_{y=0}^{N-1}f(x,y)e^{-j 2\pi(ux / M + vy / N)}$
- 二维离散傅里叶反变换 (IDFT)
    - $\displaystyle f(x,y) = \frac{1}{MN}\sum_{u=0}^{M-1}\sum_{v=0}^{N-1}F(u,v)e^{j 2\pi(ux / M + vy / N)}$

旋转性:

- $\displaystyle f(r,\theta+\theta_0) \Leftrightarrow F(\omega, \varphi+\theta_0)$

其中使用的是极坐标.

平移性:

- $\displaystyle f(x,y)e^{j 2\pi(u_0x / M + v_0y / N)} \Leftrightarrow F(u-u_0,v-v_0)$
- $\displaystyle f(x-x_0,y-y_0) \Leftrightarrow F(u,v)e^{-j 2\pi(x_0u / M + y_0v / N)}$

如果我们令 $u_0=M/2$, $v_0=N/2$, 则有

- $f(x,y)(-1)^{x+y} \Leftrightarrow F(u-M/2,v-N/2)$

幅度, 相角与功率谱:

- 极坐标表示: $\displaystyle F(u,v)=|F(u,v)|e^{j\phi(u,v)}$
- 幅度 (傅里叶谱): $|F(u,v)| = [R^{2}(u,v)+I^{2}(u,v)]^{\frac{1}{2}}$
- 相角 ($[-\pi, \pi]$): $\displaystyle \phi(u,v) = \arctan \left[ \frac{I(u,v)}{R(u,v)} \right]$
- 功率谱: $P(u,v) = |F(u,v)|^{2} = R^{2}(u,v) + I^{2}(u,v)$

二维离散卷积:

- $\displaystyle f(x,y)*h(x,y) = \sum_{m=0}^{M-1}\sum_{n=0}^{N-1}f(m,n)h(x-m,y-n)$
    - 该式给出了一个二维周期序列中的一个周期, 因此也被称为循环卷积
- $f(x,y)*h(x,y) \Leftrightarrow F(u,v)H(u,v)$
- $f(x,y)h(x,y) \Leftrightarrow F(u,v)*H(u,v)$

要理解循环卷积, 我们可以使用一个一维序列来说明:

对于 $\displaystyle y(x) = f(x)*h(x) = \sum_{m=0}^{M-1}\sum_{n=0}^{N-1}f(m,n)h(x-m,y-n)$

用矩阵形式表示就是

$
\begin{bmatrix} y(0) \\ y(1) \\ y(2) \\ \vdots \\ y(M-1) \\\end{bmatrix} = \begin{bmatrix} h(0) & h(M-1) & h(M-2) & \cdots  & h(1) \\ h(1) & h(0) & h(M-1) & \cdots & h(2) \\ h(2) & h(1) & h(0) & \cdots & h(3) \\ \vdots & \vdots & \vdots & \vdots & \vdots\\ h(M-1) & h(M-2) & h(M-3) & \cdots &h(0) \end{bmatrix}\begin{bmatrix} f(0) \\ f(1) \\ f(2) \\ \vdots \\ f(M-1) \\\end{bmatrix}
$

可以看出, 如果周期过于相近的话, 会产生缠绕错误, 所以我们要在 $f(x)$ 和 $h(x)$ 末尾处进行零填充, 使得 $M \ge M_{f}+M_{h}-1$.

二维同理, 也要进行零填充.

但是有一个问题, 我们如何对频率域滤波器 $H(u,v)$ 进行零填充?

- 先将 $H(u,v)$ 转为空间域的 $h(x,y)$, 进行零填充后再转回来
    - 会出现振铃现象, 因此并不实用
- 不进行零填充, 直接构造一个与 $F(u,v)$ 一样大小的 $H(u,v)$
    - 没有完全解决缠绕问题, 但是问题不大, 因为图像已经经过零填充了


### 1.3 快速傅里叶变换 (FFT)

对于离散傅里叶变换对

- 离散傅里叶变换 (DFT):
    - $\displaystyle F(u) = \sum_{x=0}^{M-1}f(x) e^{-j 2\pi ux / M}, u = 0,1,2,\cdots, M-1$
- 离散傅里叶反变换 (IDFT):
    - $\displaystyle f(x) = \frac{1}{M}\sum_{u=0}^{M-1}F(u) e^{j 2\pi ux / M}, x = 0,1,2,\cdots, M-1$

我们将 $\omega_{M}^{k} = e^{-j 2\pi k / M}$ 给抽取出来, 则有

- 离散傅里叶变换 (DFT):
    - $\displaystyle F(u) = \sum_{x=0}^{M-1}f(x) (e^{-j 2\pi u / M})^x = \sum_{x=0}^{M-1}f(x)(\omega_{M}^{u})^{x}$
- 离散傅里叶反变换 (IDFT):
    - $\displaystyle f(x) = \frac{1}{M}\sum_{u=0}^{M-1}F(u) (e^{j 2\pi x / M})^u = \frac{1}{M}\sum_{u=0}^{M-1}F(u)(\omega_{M}^{-x})^u$

其中 $\omega_{M}^{k} = e^{-j 2\pi k / M}$ 代表着复平面上将单位圆 $M$ 等分, 并以原点为起点, 以 $k$ 等分点为终点形成的向量. 

因此我们很自然地就能得到两个相关性质:

- 折半引理: $\omega_{2M}^{2k} = \omega_{M}^{k}$
    - 由几何意义可知, 两者表示的向量终点是一样的.
- 消去引理: $\omega_{M}^{k + M / 2} = -\omega_{M}^{k}$
    - 由几何意义可知, 两者表示的向量方向恰好相反.

> 一个 $n - 1$ 次多项式在 $n$ 个不同点处的取值唯一确定了该多项式.

因此, 我们也可以将离散傅里叶变换视作 **多项式的点值表示** 过程. 其中 $f(x)$ 是多项式的系数, $\omega_{M}^{k}$ 是我们带入的不同点, 最后求出点值表示 $F(u)$.

我们对多项式 $\displaystyle f(x) = \sum_{i=0}^{n-1}a_ix^{i}$ 进行研究, 我们带入 $x=\omega_{n}^{k}$, 并对多项式以奇偶的方式进行划分, 则有

$
\begin{aligned}
f(x) &= (a_0x^{0} + a_2x^{2} + \cdots + a_{n-2}x^{n-2}) \\
&+ (a_1x^{1} + a_3x^{3} + \cdots + a_{n-1}x^{n-1}) \\
\end{aligned}
$

令 $f_1(x) = a_0x^{0} + a_2x^{1} + \cdots + a_{n-2}x^{\frac{n}{2}-1}$, $f_2(x) = a_1x^{0} + a_3x^{1} + \cdots + a_{n-1}x^{\frac{n}{2}-1}$

则有 $f(x) = f_1(x^{2}) + xf_2(x^{2})$

带入 $x = \omega_{n}^{k}$ 有

$
\begin{aligned}
f(\omega_{n}^{k}) &= f_1(\omega_{n}^{2k}) + \omega_{n}^{k}f_2(\omega_{n}^{2k}) \\
&= f_1(\omega_{\frac{n}{2}}^{k}) + \omega_{n}^{k}f_2(\omega_{\frac{n}{2}}^{k}) \\
\end{aligned}
$

带入 $x = \omega_{n}^{k+\frac{n}{2}}$ 有

$
\begin{aligned}
f(\omega_{n}^{k+\frac{n}{2}}) &= f_1(\omega_{n}^{2k+n}) + \omega_{n}^{k+\frac{n}{2}}f_2(\omega_{n}^{2k+n}) \\
&= f_1(\omega_{n}^{2k}\cdot \omega_{n}^{n}) - \omega_{n}^{k}f_2(\omega_{n}^{2k}\cdot \omega_{n}^{n}) \\
&= f_1(\omega_{n}^{2k}) - \omega_{n}^{k}f_2(\omega_{n}^{2k}) \\
&= f_1(\omega_{\frac{n}{2}}^{k}) - \omega_{n}^{k}f_2(\omega_{\frac{n}{2}}^{k}) \\
\end{aligned}
$

其中 $\displaystyle k < \frac{n}{2}$.

由此可见, 我们只需要递归地求出 $f_1(\omega_{\frac{n}{2}}^{k}), f_2(\omega_{\frac{n}{2}}^{k})$ 即可 $O(1)$ 地合并结果.

因此我们能够用 $O(\log n)$ 的时间复杂度求出 $f(\omega_{n}^{k})$, 进而可以用 $O(n\log n)$ 的时间复杂度求出所有的 $f(\omega_{n}^{k}), k=0,2,\cdots,n-1$.

同理, 对于离散傅里叶反变换, 我们只需要将傅里叶正变换中乘上的单位根变为其共轭复数, 分治完的每一项除以 $n$ 即可得到原多项式的每一项系数.

相比于直接进行离散傅里叶变换 (DFT) 所用的 $O(n^{2})$ 的时间复杂度, 快速傅里叶变换 (FFT) 的 $O(n\log n)$ 有着显著的加速.


### 1.4 二维快速傅里叶变换 (FFT2)

二维傅里叶变换是在一维傅里叶变换基础上实现的, 实现方法为:

1. 对 2 维输入数据的每一行进行 FFT 变换, 变换结果仍然按行存入一个二维数组中;
2. 对按行 FFT 变换后的结果, 对每一列进行FFT变换, 变换结果仍然按列存入一个二维数组中, 该数组即为 2 维FFT变换结果.

对于一个 $M \times N$ 的二维数据, FFT2 的时间复杂度为 $O(MN\log(MN))$.

若 $M=N$, 则时间复杂度可以简化为 $O(N^2\log N)$, 优于暴力算法的 $O(N^{3})$.

### 1.5 频率域滤波

频率域滤波步骤如下:

1. 给定一副大小为 $M \times N$ 的输入图像 $f(x, y)$, 选择填充参数 $P$ 和 $Q$. 典型地, 我们选择 $P = 2M$ 和 $Q = 2N$.
2.  对 $f(x, y)$ 添加必要数量的 $0$, 形成大小为 $P × Q$ 的填充后图像 $f_{p}(x, y)$.
3. 用 $(−1)^{x+y}$ 乘以 $f(x,y)$ 移到其变换的中心.
4. 计算来自步骤 3 的图像的 DFT, 得到 $F(u, v)$.
5. 生成一个实的、对称的滤波函数 $H(u, v)$, 其大小为 $P \times Q$, 中心在 $(P / 2, Q / 2)$ 处. 用阵列相乘形成乘积 $G(u,v)=H(u,v)F(u,v)$.
6. 得到处理后的图像: $g_{p}(x,y) = \{ \operatorname{real}[\mathfrak{I}^{-1}[G(u,v)]] \}(-1)^{x+y}$
7. 通过 $g_{p}(x,y)$ 的左上象限提取 $M \times N$ 区域，得到最终处理结果 $g(x,y)$.

### 1.6 不同的滤波器

#### 1.6.1 拉普拉斯算子 (Laplace)

标准形式:

$\begin{bmatrix} 0 & 1 & 0 \\ 1 & -4 & 1 \\ 0 & 1 & 0 \\\end{bmatrix}$

对角线形式:

$\begin{bmatrix} 1 & 1 & 1 \\ 1 & -8 & 1 \\ 1 & 1 & 1 \\\end{bmatrix}$

#### 1.6.2 Sobel 算子 (Sobel)

$\begin{bmatrix} -1 & 0 & 1 \\ -2 & 0 & 2 \\ -1 & 0 & 1 \\\end{bmatrix}$

#### 1.6.3 巴特沃斯低通滤波器 (Butterworth)

$\displaystyle H(u,v) = \frac{1}{1+([(u-P / 2)^{2}+(v-Q / 2)^{2}]^{\frac{1}{2}} / D_0)^{2n}}$

#### 1.6.4 高斯低通滤波器 (Gaussian)

$H(u,v) = e^{-[(u-P / 2)^{2}+(v-Q / 2)^{2}] / 2\sigma^{2}}$


## 二、具体实现

### 2.0 实现快速傅里叶变换 (FFT) 和各种滤波器

为了实现快速傅里叶变换, 我依照理论基础部分的算法, 使用了递归的方式实现了一维快速傅里叶变换.

```python
def fft(a: np.ndarray, n=None, inverse=False) -> np.ndarray:
    if n is None:
        n = a.shape[0]
    # crop or pad
    if n > a.shape[0]:
        a = np.pad(a, (0, n - a.shape[0]), 'constant')
    elif n < a.shape[0]:
        a = a[:n]
    # fft
    if n == 1:
        return a
    # 解决非 2 的幂次的问题
    if n % 2 != 0:
        return dft(a, n, inverse)
    else:
        # 分奇偶
        a_even = a[::2]
        a_odd = a[1::2]
        # 递归
        A_even = fft(a_even, n // 2, inverse)
        A_odd = fft(a_odd, n // 2, inverse)
        # 把所有的项相乘
        if inverse:
            W = np.exp(2j * np.pi * np.arange(n) / n)
        else:
            W = np.exp(-2j * np.pi * np.arange(n) / n)
        # W = W.reshape(-1, 1)
        return np.concatenate([A_even + W[:n // 2] * A_odd,
                               A_even + W[n // 2:] * A_odd])

def ifft(a: np.ndarray, n=None):
    if n is None:
        n = a.shape[0]
    return fft(a, n, inverse=True) / n
```

然后在一维快速傅里叶变换的基础上, 我实现了二维快速傅里叶变换:

1. 对 2 维输入数据的每一行进行 FFT 变换, 变换结果仍然按行存入一个二维数组中;
2. 对按行 FFT 变换后的结果, 对每一列进行FFT变换, 变换结果仍然按列存入一个二维数组中, 该数组即为 2 维FFT变换结果.

```python
def fft2(a: np.ndarray, s: Iterable = (None, None), inverse=False):
    # 行变换
    F = np.array([fft(a[i], s[0], inverse)
                 for i in tqdm(range(a.shape[0]))])
    # 列变换
    F = np.array([fft((F.T)[i], s[1], inverse)
                 for i in tqdm(range((F.T).shape[0]))]).T
    return F


def ifft2(a: np.ndarray, s: Iterable = (None, None)) -> np.ndarray:
    s = (s[0] or a.shape[0], s[1] or a.shape[1])
    return fft2(a, s, inverse=True) / (s[0] * s[1])
```

**遇到的问题:**

值得注意的是, 我在实现快速傅里叶变换的过程中, 发现我实现的只是以 2 为基底的快速傅里叶变换, 而非像 matlab 或 numpy 那样的一般性分解的快速傅里叶变换. 因此, 我实现的快速傅里叶变换原本只支持 $n=2^{k}$ 的情况.

但是对于一张图像来说, $n = 2^{k}$ 的情况少之又少, 例如 Assignment 1 里的图像就是 $784 \times 784$ 的, 而 $n = 784 = 49 \times 2^{4} \neq 2^{k}$.

但是实现一般性分解的快速傅里叶变换又过于复杂, 我实在是心有余而力不足, 因此使用了一种更为简单的方法.

我实现了最简单也是最通用的离散傅里叶变换方法 (DFT):

```python
def dft(a: np.ndarray, n=None, inverse=False):
    if n is None:
        n = a.shape[0]
    # crop or pad
    if n > a.shape[0]:
        a = np.pad(a, (0, n - a.shape[0]), 'constant')
    elif n < a.shape[0]:
        a = a[:n]
    if inverse:
        return np.array([
            np.sum(a * np.exp(2j * np.pi * k * np.arange(n) / n))
            for k in range(n)])
    else:
        return np.array([
            np.sum(a * np.exp(-2j * np.pi * k * np.arange(n) / n))
            for k in range(n)])
```

然后在 FFT 的过程中, 遇到不能对半分的情况, 就直接调用 DFT 函数来解决:

```python
# ...
# 解决非 2 的幂次的问题
if n % 2 != 0:
    return dft(a, n, inverse)
```

这样, 就能使用最少的代码实现出一个足够使用的傅里叶变换方法了.

这样做的话, 最优情况下算法复杂度为 $O(n\log n)$, 最坏情况下算法复杂度为 $O(n^{2})$.

但是 Python 本身就已经挺慢的了, 相对于直接使用 `numpy.fft.fft2`, 自己实现的傅里叶变换速度有着显著的下降.

除了傅里叶变换外, 我还实现了 `fspecial_gaussian` 函数, 用于生成高斯低通滤波器:

```python
def fspecial_gaussian(shape: Iterable, sigma: float) -> np.ndarray:
    m, n = [(ss - 1.) / 2. for ss in shape]
    y, x = np.ogrid[-m:m + 1, -n:n + 1]
    h = np.exp(-(x * x + y * y) / (2. * sigma * sigma))
    h[h < np.finfo(h.dtype).eps * h.max()] = 0
    sumh = h.sum()
    if sumh != 0:
        h /= sumh
    return h
```

### 2.1 Assignment 1

频率域滤波步骤如下:

1. 给定一副大小为 $M \times N$ 的输入图像 $f(x, y)$, 选择填充参数 $P$ 和 $Q$. 典型地, 我们选择 $P = 2M$ 和 $Q = 2N$.
2.  对 $f(x, y)$ 添加必要数量的 $0$, 形成大小为 $P × Q$ 的填充后图像 $f_{p}(x, y)$.
3. 用 $(−1)^{x+y}$ 乘以 $f(x,y)$ 移到其变换的中心.
4. 计算来自步骤 3 的图像的 DFT, 得到 $F(u, v)$.
5. 生成一个实的、对称的滤波函数 $H(u, v)$, 其大小为 $P \times Q$, 中心在 $(P / 2, Q / 2)$ 处. 用阵列相乘形成乘积 $G(u,v)=H(u,v)F(u,v)$.
6. 得到处理后的图像: $g_{p}(x,y) = \{ \operatorname{real}[\mathfrak{I}^{-1}[G(u,v)]] \}(-1)^{x+y}$
7. 通过 $g_{p}(x,y)$ 的左上象限提取 $M \times N$ 区域，得到最终处理结果 $g(x,y)$.

因此对应的代码为:

```python
def my_imfilter(f: np.ndarray, P: int, Q: int, H: np.ndarray,
        use_numpy=False) -> np.ndarray:
    # 2. 为 f(x,y) 添加必要数量的 0, 此处省略
    M, N = f.shape
    # 3. 用 (-1)^(x+y) 乘以 f(x,y) 移到变换中心
    x = np.arange(M)[:, None]
    y = np.arange(N)[None, :]
    f = f * (-1) ** (x + y)
    # 4. 计算 f(x,y) 的傅里叶变换得到 F(u,v)
    if use_numpy:
        F = np.fft.fft2(f, (P, Q))
    else:
        F = fft2(f, (P, Q))
    # 5. 生成一个频域滤波器 H(u,v),
    #    并用阵列相乘形成 G(u,v) = H(u,v) * F(u,v)
    G = H * F
    # 6. 得到 g_p(x,y), 即 G(u,v) 的傅里叶逆变换,
    #    转换为实部, 并乘上 (-1)^(x+y)
    x = np.arange(P)[:, None]
    y = np.arange(Q)[None, :]
    if use_numpy:
        g_p = np.fft.ifft2(G).real * (-1) ** (x + y)
    else:
        g_p = ifft2(G).real * (-1) ** (x + y)
    # 7. 截取 g_p(x,y) 的左上部分 (M x N), 得到 g(x,y)
    return g_p[:M, :N]
```

然后我分别显示了三张不同处理的图片 (且保存):

```python
def main():
    use_numpy = False
    # 1. 加载 ../asset/image/432.tif
    #    并得到输入图像的大小
    f = mpimg.imread('../asset/image/432.tif')
    # 归一化
    f = f / 256
    # 显示三张图像
    plt.subplot(1, 3, 1)
    plt.imshow(f, cmap='gray')
    M, N = f.shape

    # 不进行零填充
    P, Q = M, N
    H = fspecial_gaussian((P, Q), 10)
    g_no_zero_padded = my_imfilter(f, P, Q, H, use_numpy=use_numpy)
    plt.subplot(1, 3, 2)
    plt.imshow(g_no_zero_padded, cmap='gray')

    # 进行零填充
    P, Q = 2 * M, 2 * N
    H = fspecial_gaussian((P, Q), 10)
    g_zero_padded = my_imfilter(f, P, Q, H, use_numpy=use_numpy)
    plt.subplot(1, 3, 3)
    plt.imshow(g_zero_padded, cmap='gray')

    # 保存图像 g_no_zero_padded 和 g_zero_padded
    mpimg.imsave('../asset/result/432_g_no_zero_padded.jpg',
                 g_no_zero_padded, cmap='gray')
    mpimg.imsave('../asset/result/432_g_zero_padded.jpg',
                 g_zero_padded, cmap='gray')

    plt.show()
```

![](images/2022-11-10-00-17-34.png)

可以看出结果显示与说明文档一致.

同时, 我也将处理后的图像保存在了 `assignment1/asset/result/` 目录下.
