# Cheat Sheet

## 分析基础

1. 插入排序
   1. 类比整理扑克牌
   2. 不变量 (Invariant) 是 $A[1...j-1]$ 有序
   3. 稍微修改就成为冒泡算法
2. 时间复杂度
   1. $f(n)\in O(g(n))$ 表示存在某些常量 $c$ 使得在 $n_0$ 之后 $f(n)\leqslant cg(n)$
   2. 说人话, 就是一个可以达到的上界
   3. $f(n)\in \Omega(g(n))$ 表示存在某些常量 $c$ 使得在 $n_0$ 之后 $f(n)\geqslant  cg(n)$
   4. 说人话, 就是一个可以达到的下界
   5. 既是 $O$ 也是 $\Omega$ 的话, 就成为 $\Theta$ 了, 即等阶
   6. $f(n)\in o(g(n))$ 表示对任何常量 $c$, 在 $n_0$ 之后 $f(n)< cg(n)$
   7. 说人话, 就是一个达不到的上界, 和 $\Omega$ 恰好相反
   8. $f(n)\in \omega(g(n))$ 表示对任何常量 $c$, 在 $n_0$ 之后 $f(n)> cg(n)$
   9. 说人话, 就是一个达不到的下界, 和 $O$ 恰好相反
3.  常用工具
    1.  洛必达法则
    2.  斯特林近似: $\displaystyle  n!\sim  \sqrt{2\pi n}\left( \frac{n}{e} \right)^{n}, \sqrt{c_0 n}\left( \frac{n}{e} \right)^{n}\leqslant n!\leqslant \sqrt{c_1 n}\left( \frac{n}{e} \right)^{n}$


## 结构基础

1. 抽象数据类型 (Abstract Data Type)
2. 队列
   1. FIFO 队列
      1. `Enqueue(x)`
      2. `Dequeue()`
   2. LIFO 队列, 栈 (Stack)
      1. `Add(x)` 或 `Push(x)`
      2. `Remove()` 或 `Pop()`
   3. 双端队列 (Deque)
   4. 列表 (List)
      1. `Size()`
      2. `Get(i)`
      3. `Set(i, x)`
      4. `Add(i, x)`
      5. `Remove(i)`
      6. 我们可以用循环数组来实现列表, 进而实现双端队列
      7. 如果用双向链表实现的话, 记得加一个哨兵 (Sentinel)
3. 应用
   1. 栈可以用来平衡符号 (Balancing Symbols)
   2. 栈可以用来计算后序表达式, 不需要括号和优先级, 就已经有能力表示和计算任何的二元表达式
      1. 设定两个栈, 操作数栈和操作符栈, 便可以计算中序表达式
   3. 两个 FIFO 可以实现一个 LIFO, 反之亦然
   4. 栈可以实现函数调用, 同理, 任何的递归也可以改用循环和栈来实现
   5. 尾递归可以直接改成循环, 不需要栈, 只需要在 `while(True)` 循环尾部将函数参数改为对应参数即可
   6. 随机队列: 添加时加入到数组尾部, 取出时随机取出, 然后将数组尾部元素移动到该位置
   7. 使用 $O(n)$ 的时间和 $O(1)$ 的空间可以逆转一个链表
   8. 使用异或可以只用一个指针就实现两个指针的效果


## 分治法

1. 分治: 将问题递归地划分为子问题, 分别进行处理, 最后将处理结果统合起来
2. MergeSort
   1. 进行二分, 然后在 $O(n)$ 的时间内将两个有序的数组融合 (Combine).
   2. 时间复杂度: $T(n)=2T(n/2)+O(n)$
   3. 每一层复杂度都是 $n$, 一共 $\log n$ 层, 最后的时间复杂度为 $T(n)=n\log n$
   4. 或者使用一个 FIFO 队列, 每次取出两个有序数组, 融合成一个有序数组之后重新放入队列中
3. 整数乘法
   1. $xy=x_{l}y_{l}\cdot 2^{n}+[(x_{l}+x_{r})(y_{l}+y_{r})-x_{l}y_{l}-x_{r}y_{r}]\cdot 2^{\frac{n}{2}}+x_{r}y_{r}$
   2. $T(n)=3T(n/2)+O(n)$
   3. $T(n)=O(n^{\lg 3})<O(n^{2})$
4. 矩阵乘法
   1. $T(n)=7T(n/2)+\Theta(n^{2})$
5. 替代法
   1. 已知 $T(n)=7T(n/2)+cn^{2}$
   2. 猜测 $T(n)\leqslant d_1n^{\lg 7}-d_2n^{2}$
   3. 用归纳法, 带入, 放缩即可
6. 递归树法
   1. 将递归树画出来, 分析每一层的消耗
   2. 指数递减: 只看第一层, 则 $T(n)=O(f(n))$
   3. 各层相等: 每一层加起来, 则 $T(n)=O(f(n)\lg n)$
   4. 指数递增: 只看最后一层, 则 $T(n)=O(n^{\log_{c}r})$
7. 主定理
   1. 即递归树法的增强版本
   2. 通过分析 $f(n)$ 与 $aT(n/b)$ 的关系, 即可知道究竟是三种情况中的哪种情况
   3. 指数递减: $f(n)$ 比较大, $f(n)=\Omega(n^{\log_{b}a+\epsilon})$
   4. 各层相等: $f(n)$ 恰好相等, $f(n)=\Theta(n^{\log_{b}a})$
   5. 指数递增: $f(n)$ 比较小, $f(n)=O(n^{\log_{b}a-\epsilon})$
8. 划分规模不等
   1. 先使用递归树法获得一个猜测值
   2. 再使用替代法证明结果是正确的
9. 使用 MergeSort 可以用来计算逆序对个数
   1. 逆序对 = 两个子序列的逆序对 + 融合过程中产生的新的逆序对
10. 一些奇怪的复杂度分析
    1. $T(n)=T(n-2)+T(n/2)+n$
       1. 画出递推树, 发现可以向左下角倾斜地计算, 每一层 $\displaystyle (\frac{n}{4^{i}})^{2}$ 最多出现 $n^{i}$ 次
       2. $\displaystyle T(n)\leqslant \sum_{i=1}^{\log n}(\frac{n}{4^{i}})^{2}\cdot n^{i}=n^{O(\log n)}$
    2. $T(n)=T(\alpha n)+T((1-\alpha)n)+cn$
       1. $T(n)=O(n\log n)$
11. 选举人问题
    1. 划分成两个子问题, 然后取出每一个组的主选举人和拥有相同派别的人数


## 堆

1. 二叉堆
   1. 最大堆
      1. 顶部有着最大值
      2. 每个子堆也是最大堆
      3. 是完全二叉树
2. 用数组表示二叉堆
   1. 父节点: `idx / 2`
   2. 左子节点: `2 * idx`
   3. 右子节点: `2 * idx + 1`
3. 最大堆
   1. `HeapInsert()`
      1. 加到数组尾部, 然后与父节点比较, 大于则交换, 逐层向上
      2. $T(n)=O(\log n)$
   2. `HeapGetMax()`
      1. 返回数组的首值
      2. $T(n)=O(1)$
   3. `HeapExtractMax()`
      1. 去除数组头部, 将数组尾部放到头部
      2. 头部与两个子节点比较, 小于的话, 与更大的子节点交换, 逐层向下
      3. $T(n)=O(\log n)$
4. 优先队列
   1. 可以用最大堆实现优先队列
5. 堆排序
   1. 建好一个最大堆, 然后不断从中取出最大值
   2. 从数组中建堆
      1. 不断加入值
         1. $T(n)=n\log n$
      2. 或者直接用原数组建堆
         1. 逐层使用 `MaxHeapify(i)`
         2. 即 `for i in range(n / 2, 1) do MaxHeapify(i)`
         3. $\displaystyle T(n)=\sum_{h=0}^{\log n}(\frac{n}{2^{h}}\cdot O(h))=O(n\cdot \sum_{h=0}^{\log n}\frac{h}{2^{h}})=O(n)$
   3. 不断取出最大值, 然后放入堆尾部
      1. $T(n)=n\log n$
6. 在最大堆中取出第 $k$ 大的元素
   1. 要求时间复杂度为 $O(k\log k)$, 而不是 $O(k\log n)$
   2. 使用另一个堆 $H$ 来协助, 先往 $H$ 里加入 $M$ 的最大值
   3. 不断在 $H$ 取出最大值, 然后往 $H$ 放入该最大值的两个子节点
   4. 执行 $k-1$ 之后, $H$ 里就是第 $k$ 大的元素了


## 排序问题

1. 排序算法的性质
   1. 插入排序
      1. $O(n^{2})$ 时间, $O(1)$ 额外空间
      2. 稳定
   2. 归并排序
      1. $O(n\log n)$ 时间, $O(n)$ 额外空间
      2. 稳定
   3. 堆排序
      1. $O(n\log n)$ 时间, $O(1)$ 额外空间
      2. 不稳定
2. 快排
   1. 选出主元
   2. 使用 `Partition` 将数组分为两部分
   3. 还可以加入随机化算法
3. 问题的上界和下界
   1. 对于某个具体的问题, 有其对应的上界和下界
   2. 对于某个具体的算法才有上界, 即最坏情况下算法 $A$ 所需要的时间
   3. 解决该问题的所有算法对应的上界, 取其最小值, 即是下界
4. 如何证明问题的下界
   1. 使用对手论证, 假设一个 Eve 在与你作对, 然后你问问题, 它回答, 你要问够足够多的信息才有可能正确回答这个问题
   2. 例如可以使用这种方式证明 $\Omega(n)$ 是排序问题的一个下界
5. 如果计算问题的下界
   1. 使用决策树法
   2. 我们使用比较的方法来进行排序, 每次比较都会分成两个分支, 所以是二叉树
   3. 排序问题的所有结果可能性, 共有 $n!$ 中, 即这棵树至少有 $n!$ 片叶子
   4. 这棵树的高度至少为 $\log n!=\Omega(n\log n)$
6. 桶排序
   1. 不基于比较, 类似于哈希表
   2. 加入到 $d$ 个桶之后, 然后进行排序   
7. 基数排序
   1. 桶排序的一种应用场景
   2. 可以用来排序字符串


## 选择问题

1. 同时找出最大值和最小值
   1. 我们先两两分组, 然后找出 "局部" 最大值和最小值
   2. 然后从这些 "局部" 最大值和最小值中分别找 "全局" 最大值和最小值 
   3. 这也是我们能做到的最好了
      1. 给每个元素标号, "+" 表示可能为最大值, "-" 表示可能为最小值
      2. 我们要做的就是把标号清除
2. 通用选择问题
   1. 魔改快排
   2. 我们可以证明, 预期花费的时间是 $O(n)$
   3. 并且, 在找到之后, 会将数组左边变为都比其小的元素, 右边变为都比其大的元素
   4. 我们可以使用 Median of medians 的方法, 将预期为 $O(n)$ 变为一定是 $O(n)$


## 树

1. 二叉树的分类
   1. 满二叉树: 任何一个节点要么没有子节点, 要么有两个子节点
   2. 完全二叉树: 类比堆
   3. 完美二叉树: 刚刚好形成一个三角形的那种情况
2. 树的遍历
   1. 先序遍历
   2. 中序遍历
   3. 后序遍历
   4. 层次遍历: 使用一个 FIFO 队列实现
3. 二叉搜索树
   1. 唯一要注意的就是删除, 要用到找后继







