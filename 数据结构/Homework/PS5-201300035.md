# Solution for Problem Set 5

## Problem 1

**(a)**

**Overview:**

QuickSelect(A, i) will divide an array to two parts via the i-th smallest element in time $O(n)$. We can use QuickSelect(A, i) to $k$-sort an arbitrary array in $O(n\log k)$ time. If $n/2$ is even, select median and partition it by QuickSelect(A, n/2). If $n/2$ is odd, remove a small part by QuickSelect(A, n/k) and then it will be same with case that is even. Each times we use $O(n)$ time and it will be $\log k$ times, so the final time complexity is $O(n\log k)$.

**Algorithm:**

<pre class="pseudocode">
\begin{algorithm}
\caption{K-Sort}
\begin{algorithmic}

\FUNCTION{K-Sort}{$A[1...n], k$}
    \IF{n == k}
        \RETURN
    \ENDIF
    \IF{n/2 is even}
        \STATE QuickSelect(A[1...n], n/2)
        \STATE K-Sort(A[1...n/2], k)
        \STATE K-Sort(A[n/2+1...n], k)
    \ENDIF
    \IF{n/2 is odd}
        \STATE QuickSelect(A[1...n], n/k)
        \STATE QuickSelect(A[n/k+1...n], (n-n/k+1)/2)
        \STATE K-Sort(A[n/k+1...(n+n/k)/2], k)
        \STATE K-Sort(A[(n+n/k)/2+1...n], k)
    \ENDIF
\ENDFUNCTION

\end{algorithmic}
\end{algorithm}
</pre>

**Correctness:**

After the first call, the array will be divided into two or three part, and $A[1...n/2]\prec A[n/2+1...n]$, or $A[1...n/k]\prec A[n/k+1...(n+n/k)/2]\prec A[(n+n/k)/2+1...n]$.

After several times of this process, the length of smallest part will be $k$ and $A[1...n/k]\prec A[n/k+1...2n/k]\prec...\prec A[n-n/k+1...n]$. It is k-sorted.

**Time Complexity:**

When $n=k$, $\displaystyle T(n)=\Theta(1)$.

When $n$ is even, $\displaystyle T(n)=2T(\frac{n}{2})+O(n)$.

When $n$ is odd, $\displaystyle T(n)=2T(\frac{n}{2}-\frac{2n}{k})+O(n)\leqslant T(\frac{n}{k})+2T(\frac{n}{2}-\frac{2n}{k})+O(n)$.

So by the recursive tree method we can know that the final time complexity is $T(n)=O(n\log k)$.

**(b)**

The are $k$ blocks and total size is $n$, so there are $\displaystyle \frac{n!}{((n/k)!)^{k}}$ different possible permutations for the $k$ blocks.

Each comparision as a question can divide it into two parts, so it is like a binary tree. The thing we need to do is find the height of the tree.

$\displaystyle \log(\frac{n!}{((n/k)!)^{k}})=\log(n)+\log(n-1)+\cdots+\log(2)-k(\log (\frac{n}{k})+\log (\frac{n}{k}-1)+\cdots+\log 2)=\Omega(n\log n- k\cdot \frac{n}{k}\log \frac{n}{k})=\Omega(n\log k)$

So any comparision-based $k$-sorted algorithm requires $\Omega(n\log k)$ comparisons in the worst case.


## Problem 2

**(a)**

We can think that we are putting coins into two boxes one by one.

$\displaystyle p=\frac{1}{2}\cdot \frac{1}{2}+(1-\frac{1}{2})(1-\frac{1}{2})=\frac{1}{2}$

**(b)**

**Overview:**

At the beginning, we randomly choose $n / 2$ of $n$ coins to put on one pan, and the remaining $n / 2$ coins on the other pan. The are two cases. if it is unbalanced, we find the fake coins by `FindTheLighter` and `FindTheHeavier` function. If it is balanced, we recall the function recursively in the two parts. Finally we will get the fake coins.

**Algorithm:**

<pre class="pseudocode">
\begin{algorithm}
\caption{FindFakeCoins}
\begin{algorithmic}

\FUNCTION{FindTheLighter}{$A[1...n]$}
    \IF{n == 1}
        \RETURN A[1]
    \ENDIF
    \IF{n == 2}
        \STATE lighter = Balance(A[1], A[2])
        \RETURN lighter
    \ENDIF
    \STATE lighter group = Balance(one part of A randomly, other part of A)
    \RETURN FindTheLighter(lighter group)
\ENDFUNCTION

\FUNCTION{FindTheHeavier}{$A[1...n]$}
    \IF{n == 1}
        \RETURN A[1]
    \ENDIF
    \IF{n == 2}
        \STATE heavier = Balance(A[1], A[2])
        \RETURN heavier
    \ENDIF
    \STATE heavier group = Balance(one part of A randomly, other part of A)
    \RETURN FindTheHeavier(heavier group)
\ENDFUNCTION

\FUNCTION{FindFakeCoins}{$A[1...n]$}
    \STATE let B = one part of A randomly, C = other part of A
    \STATE is it balanced, lighter group, heavier group = Balance(B, C)
    \IF{it is balanced}
        \STATE isFound, lighter, heavier = FindFakeCoins(B)
        \STATE isFound, lighter, heavier = FindFakeCoins(C)
        \RETURN is it found, lighter, heavier
    \ELSE
        \RETURN true, FindTheLighter(lighter group), FindTheHeavier(heavier group)
    \ENDIF
\ENDFUNCTION

\end{algorithmic}
\end{algorithm}
</pre>

The times of using Balance in FindTheLighter(A[1...n]) or FindTheHeavier(A[1...n]) is $\log n$.

The times of using Balance in FindFakeCoins(A[1...n]) where there are no fake coins is $\displaystyle \sum_{k=1}^{\log n}2^{k-1}=n - 1$.

Let $E(n)$ be the expected number of times my algorithm uses the Balance.

So, $\displaystyle E(n)=\frac{1}{2}\cdot 2\cdot \log\frac{n}{2}+\frac{1}{2}\cdot ((\frac{n}{2}-1)+E(\frac{n}{2}))=\log n+\frac{n}{4}-\frac{3}{2}+\frac{1}{2}E(\frac{n}{2})$ and $E(2)=1$

Let $n=2^{k}$, and then

$\displaystyle E(n)=E(2^{k})=k+2^{k-2}-\frac{3}{2}+\frac{1}{2}E(2^{k-1})=\sum_{k=1}^{\log n}\frac{2^{k}}{2^{\log n}}\cdot (k+2^{k-2}-\frac{3}{2})=\frac{n}{3}+\frac{14}{3n}+2\log n-5$


## Problem 3





