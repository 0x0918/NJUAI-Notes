# Solution for Problem Set 5

## Problem 1

**(a)**

![](./images/tree.png)

**(b)**

**Algorithm:**

We record the tree as $N$ recursively, let the preorder node sequences as FIFO queue be $R$, the postorder node sequences as FIFO queue be $O$.

<pre class="pseudocode">
\begin{algorithm}
\caption{RecursiveReconstruct}
\begin{algorithmic}

\FUNCTION{RecursiveReconstruct}{$N$}
    \IF{R.top() == O.top()}
        \STATE N.data = R.pop()
        \STATE O.pop()
    \ELSE
        \STATE N.data = R.pop()
        \STATE N.leftChild.parent = N
        \STATE RecursiveReconstruct(N.leftChild)
        \STATE N.rightChild.parent = N
        \STATE RecursiveReconstruct(N.rightChild)
        \STATE O.pop()
    \ENDIF
\ENDFUNCTION

\end{algorithmic}
\end{algorithm}
</pre>

**Correctness:**

For a full binary tree, which every non-leaf node has exactly two children, we reconstruct it recursively just like preorder traversal and postorder traversal.

If we only focus on the `R.pop()`, we will find it just replaced `R.push()` into `R.pop()` adapted from code of `PreorderTrav()`, so it is the inverse function of `PreorderTrav()`, it can reconstruct a tree that matches the preorder node sequences. Similarly, the reconstructed tree matches the postorder node sequences.

And the function is not a randomized algorithm, so the answer it produced is unique and correct.

**Time Complexity:**

Each turn of calling the `RecursiveReconstruct()` function will reduce the length of $R$ and $O$ by 1, and the length of $R$ and $O$ is $n$. We can conclude that the function will be called $n$ times.

Because the function's time complexity is $\Theta(1)$, without the recursive statement, the final time complexity is $T(n)=n\cdot \Theta(1)=O(n)$.

**(c)**

The answer of reconstructing an arbitrary binary tree from its preorder and postorder node sequences may be not unique.

For example, the simplest case is that preorder node sequences is `A B`, and the postorder sequences is `B A`. There are two trees meet the conditions:

![](./images/two-tree.png)

The $B$ node is the left child of $A$ or the $B$ node is the right child of $A$.

The answer is not unique so that there is no algorithm to reconstruct an arbitrary binary tree from its preorder and postorder node sequences.


## Problem 2

**Algorithm:**

In a height-balanced binary search tree, the difference between the height of the left and right subtrees of every node is never more than 1. In other words, the different between the height of the left and right subtrees of every node is never more than $2^{h-1}$, where $h$ is the height of the tree, which means that `max <= 2 * min + 1`.

So the only thing we are supposed to do is balancing the difference by $O(n)$ rotations.

Let $M$ be the global hash map for storing the count of nodes for each node.

<pre class="pseudocode">
\begin{algorithm}
\caption{Balance}
\begin{algorithmic}

\FUNCTION{InitCount}{$N$}
    \IF{$N$ == NULL}
        \RETURN 0
    \ENDIF
    \STATE count = InitCount($N$.leftChild) + InitCount($N$.rightChild) + 1
    \STATE $M$.set(key = $N$, value = count)
    \RETURN count
\ENDFUNCTION

\FUNCTION{RecursiveBalance}{$N$}
    \STATE leftCount = $M$.get(key = $N$.leftChild)
    \STATE rightCount = $M$.get(key = $N$.rightChild)
    \WHILE{leftCount > 2 * rightCount + 1 \OR rightCount > 2 * leftCount + 1}
        \IF{leftCount > 2 * rightCount + 1}
            \STATE middleCount = $M$.get(key = $N$.leftChild.rightChild)
            \STATE leftLeftCount = $M$.get(key = $N$.leftChild.leftChild)
            \IF{rightCount + middleCount > 2 * leftLeftCount + 1}
                \STATE temp = $N$.leftChild
                \STATE $N$.leftChild = $N$.leftChild.rightChild
                \STATE $M$.set(key = temp, value = rightCount + middleCount + 1)
                \STATE $M$.set(key = temp.leftChild, value = rightCount + leftCount + 1)
                \STATE leftRotation(temp)
            \ELSE
                \STATE $M$.set(key = $N$, value = rightCount + middleCount + 1)
                \STATE $M$.set(key = $N$.leftChild, value = rightCount + leftCount + 1)
                \STATE rightRotation($N$)
                \STATE $N$ = $N$.leftChild
                \STATE leftCount = $M$.get(key = $N$.leftChild)
                \STATE rightCount = $M$.get(key = $N$.rightChild)
            \ENDIF
        \ELSE
            \STATE middleCount = $M$.get(key = $N$.rightChild.leftChild)
            \STATE rightRightCount = $M$.get(key = $N$.rightChild.rightChild)
            \IF{leftCount + middleCount > 2 * rightRightCount + 1}
                \STATE temp = $N$.rightChild
                \STATE $N$.rightChild = $N$.rightChild.leftChild
                \STATE $M$.set(key = temp, value = leftCount + middleCount + 1)
                \STATE $M$.set(key = temp.rightChild, value = leftCount + rightCount + 1)
                \STATE rightRotation(temp)
            \ELSE
                \STATE $M$.set(key = $N$, value = leftCount + middleCount + 1)
                \STATE $M$.set(key = $N$.rightChild, value = leftCount + rightCount + 1)
                \STATE leftRotation($N$)
                \STATE $N$ = $N$.rightChild
                \STATE leftCount = $M$.get(key = $N$.leftChild)
                \STATE rightCount = $M$.get(key = $N$.rightChild)
            \ENDIF
        \ENDIF
    \ENDWHILE
    \STATE RecursiveBalance($N$.leftChild)
    \STATE RecursiveBalance($N$.rightChild)
\ENDFUNCTION

\FUNCTION{Balance}{root}
    \STATE InitCount(root)
    \STATE RecursiveBalance(root)
\ENDFUNCTION

\end{algorithmic}
\end{algorithm}
</pre>

**Time Complexity:**

For each node, we will balance it by the main part of `RecursiveBalance()` function. In the function, we do a loop with severals rotations to make sure that its subtrees be divided into two nearly equal parts. The function `RecursiveBalance()` will rotations several times, which can be divided into two parts, at most `n / 3` times middle rotations (rotations to reduce `middleCount`) and once left rotation or right rotation.

The number of total middle rotations is no more than `n` (because middle count is no more than `n`), and the number of total other rotation is also no more than `n` (because each call of the function will rotation once or none).

So the final time complexity is $T(n)=O(n)+O(n)=O(n)$

## Problem 3

**Algorithm:**

<pre class="pseudocode">
\begin{algorithm}
\caption{Transform}
\begin{algorithmic}

\FUNCTION{RecursiveRotationsToChain}{$N$}
    \WHILE{$N$.leftChild != NULL}
        \STATE temp = $N$
        \STATE $N$ = temp.leftChild
        \STATE rightRotation(temp)
    \ENDWHILE
    \STATE RecursiveRotationsToChain($N$.rightChild)
    \STATE Return $N$
\ENDFUNCTION

\FUNCTION{MoveParentIntoTree}{$N$}
    \IF{$N$.leftChild == NULL \AND $N$.rightChild == NULL}
        \RETURN
    \ENDIF
    \IF{$N$.leftChild == NULL}
        \IF{$N$.data < $N$.rightChild.data}
            \STATE leftRotation($N$)
        \ELSE
            \STATE SwapSubtree($N$)
            \STATE rightRotation($N$)
        \ENDIF
    \ELSE
        \IF{$N$.data < $N$.leftChild.data}
            \STATE rightRotation($N$)
        \ELSE
            \STATE SwapSubtree($N$)
            \STATE leftRotation($N$)
        \ENDIF
    \ENDIF
    \STATE MoveParentIntoTree($N$)
\ENDFUNCTION

\FUNCTION{RecursiveBuildTree}{$N$}
    \IF{$N$.rightChild == NULL}
        \RETURN $N$
    \ENDIF
    \STATE RecursiveBuildTree($N$.rightChild)
    \STATE $N$ = MoveParentIntoTree($N$)
    \RETURN $N$
\ENDFUNCTION

\FUNCTION{Transform}{root}
    \STATE root = RecursiveRotationsToChain(root)
    \STATE RecursiveBuildTree(root)
\ENDFUNCTION

\end{algorithmic}
\end{algorithm}
</pre>

**Time Complexity:**

RecursiveRotationsToChain: $T_1(n)=O(n!)=O(n^{2})$

RecursiveBuildTree: $\displaystyle T_2(n)=O(n!)=O(n^{2})$

$\therefore T(n)=O(n^{2})+O(n^{2})=O(n^{2})$


## Problem 4

**(a)**

![](./images/RB-tree.png)

**(b)**

![](./images/RB-tree-deletion.png)


## Problem 5


## Problem 6


