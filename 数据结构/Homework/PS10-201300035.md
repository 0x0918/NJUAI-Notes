# Solution for Problem Set 10

## Problem 1

**伪代码:**

```python
# 全局的哈希表, 用于缓存数据, 保证最后时间复杂度为 O(|V|+|E|)
hash_table = {}

def count_simple_paths(graph, s, t) -> int:
    # 从哈希表中取出, 时间复杂度 O(1)
    if (graph, s, t) in hash_table:
        return hash_table[(graph, s, t)]

    # 主要的计算过程
    sum = 0
    # 对于从 s 出发的每一条边
    for (s, u) in graph:
        if u == t:
            # 基础情况, s 直接与 t 相连, 则加一
            sum += 1
        else:
            # 其他情况, 递归地获取 u 到 t 的简单路径数
            sum += count_simple_paths(graph, u, t)
  
    # 保存到哈希表然后返回
    hash_table[(graph, s, t)] = sum
    return sum

# 计算 s 到 t 的所有简单路径个数并输出
print(count_simple_paths(graph, s, t))
```

**时间复杂度:**

对于所有顶点, 由于哈希表的存在, 每个节点最多只会进行一次主要的计算过程, 并且由于这是一个有向无环图, 所以我们不会重复地计算路径, 这就相当于一个深度优先搜索 DFS.

对于每一条边, 我们只会查询一次, 对于每一个顶点, 主要计算过程也仅会计算一次, 因此最后的时间复杂度为 $O(n+m)$.

## Problem 2

**伪代码:**

```python
# 一个全局的图
graph = init_graph()
# 初始化一个空列表, 用于存放所有的强连通分量 scc
# 每一个 scc 都是一个并查集
all_scc = []
# 并且我们记录不同并查集之间的互相连接
connections = []

def DFSAll(graph):
    # 对所有节点基于 finish_time 逆序排序
    # graph.nodes.sort(key=lambda u: -u.finish_time)
    # 此时已经是排好序的了
    # 初始化
    for u in graph.nodes:
        u.color = colors.WHITE
        u.parent = None
    # 对于可行的每一个节点进行 DFS
    for u in graph.nodes:
        if u.color == colors.WHITE:
            # 初始化一个 scc 并查集
            scc = make_set(u)
            DFS(graph, u, scc)
            all_scc.append(scc)


def DFS(graph, s, scc):
    s.color = colors.GRAY
    # 对于与 s 连接的每一条边
    for (s, v) in graph.edges:
        if v.color == colors.BLACK:
            # 如果 v 有对应 ssc 且是其他 ssc
            if v.find() != None and v.find() != scc: 
                # 就加入全局的 connections 中, 作为连通图的一条边
                connections.append((s, v))
        if v.color == colors.WHITE:
            v.parent = s
            DFS(graph, v)
    s.color = colors.BLACK
    # 加入并查集 scc, 代表同一个强连通分量
    scc.union(s)
      
# 1. 对 graph.reverse() 进行 DFS, 并且记录所有的完成时间 finish_time,
#    在记录的时候逆序记录为 graph
graph = DFS_and_record_finish_times(graph.reverse())

# 2. 计算所有的强连通分量和连通图的所有边
DFSAll(graph, pre_process)

# 3. 新建一个图
new_graph = init_graph()

# 4. 对于每一个连通分量, 从头至尾连接称为一个圈
for scc in all_scc:
    for i in range(len(scc)):
        new_graph.add_edge((scc.get(i), scc.get((i + 1) % len(scc))))

# 5. 然后加入连通图的所有边, 即可得到满足题意的图 G'
for connection in connections:
    u = connection[0].find()
    v = connection[1].find()
    if (u, v) not in new_graph:
        new_graph.add_edge((u, v))

# 6. 输出新的图 G'
print(new_graph)
```

**正确性:**

因为想要形成一个强连通分量, 就至少要形成一个环, 对于 $n$ 个顶点就至少需要 $n$ 条边. 而要保证有相同的连通图, 就还需要统计各个强连通分量连接的边, 并在后面不重复地加入.

最后我们生成的图就能够满足题目中的三个条件了.

**时间复杂度:**

1. 记录所有完成时间, 执行了一次 DFS, 时间复杂度为 $O(|V|+|E|)$
2. 计算所有强连通分量和连通图边, 再次执行了一次 DFS, 时间复杂度为 $O(|V|+|E|)$
3. 新建图, 时间复杂度为 $O(1)$
4. 对于每一个强连通分量, 从头至尾连成圈, 时间复杂度为 $O(|V|)$
5. 加入连通图的所有边, 时间复杂度为 $O(|E|)$
6. 输出新的图, 时间复杂度为 $O(1)$

因此总的时间复杂度为 $O(|V|+|E|)$

## Problem 3

## Problem 4
